# 운영체제
- [프로세스](https://github.com/yurak-choi/tech-interview/blob/master/cs/os.md#프로세스)
  - 프로세스 제어 블록
  - 문맥 교환
- [스레드](https://github.com/yurak-choi/tech-interview/blob/master/cs/os.md#스레드)
  - 멀티 스레드
- [스케줄러](https://github.com/yurak-choi/tech-interview/blob/master/cs/os.md#스케줄러)
  - 장기 스케줄러
  - 단기 스케줄러
  - 중기 스케줄러
- [CPU 스케줄링 알고리즘](https://github.com/yurak-choi/tech-interview/blob/master/cs/os.md#cpu-스케줄링-알고리즘)
  - FCFS
  - SJF
  - SRTF
  - 우선순위 스케줄링
  - Round Robin
- [메모리 관리](https://github.com/yurak-choi/tech-interview/blob/master/cs/os.md#메모리-관리)
  - 단편화
  - 페이징 기법
  - 세그먼테이션 기법
- [가상 메모리](https://github.com/yurak-choi/tech-interview/blob/master/cs/os.md#가상-메모리)
  - 요구 페이징
  - 페이지 교체 알고리즘
  - 스레싱

___

## 프로세스
프로세스는 수행중인 프로그램으로 디스크에서 메모리로 적재되어 실행중인 프로그램이다.

### 프로세스 제어 블록
프로세스 제어 블록(PCB : Process Control Block)이란 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스당 유지하는 정보들을 담는 커낼 내의 자료 구조이다.
- 프로세스 식별자
- 프로세스의 상태
- 프로그램 카운터 값
- CPU 레지스터
- CPU 스케줄링 정보
- 메모리 관리 정보
- 자원 사용 정보
- 입출력 상태 정보

### 문맥 교환
문맥 교환은 하나의 프로세스로부터 다른 프로세스로 CPU의 제어권을 이양하기 위해 현재 프로세스의 문맥을 자신의 PCB에 저장하고 새로 CPU를 할당받을 프로세스의 문맥을 하드웨어로 복원시키는 작업을 말한다.  
  
시스템 콜과 인터럽트가 발생(IO 요청, 타이머 인터럽트 제외)하면 CPU의 제어권이 운영체제 커널에게로 넘어가지만 프로세스가 다른 프로세스로 변경되는 과정이 아니므로 이를 문맥 교환이라고 하지 않고 모드 변경이라고 한다.

___

## 스레드
스레드는 프로세스 내에서 독립적으로 실행되는 작업 단위를 말하며 프로세스의 자원을 공유하고 각자 스택 영역을 가진다. 
각자 스택 영역을 가지는 이유는 스레드마다 독립적으로 메서드를 호출이 가능하도록 하여 독립적인 실행 흐름을 가지도록 하기 위해서이다.

### 멀티 스레드
**장점**
- CPU 사용률을 향상시킨다.
- 메모리 공유를 통해 자원을 효율적으로 사용할 수 있다.
- 여러 스레드에서 각기 다른 작업을 하게 함으로써 응답성이 향상된다.
- 프로세스 생성에 많은 시간과 자원이 소요되므로 경제적이다.

**단점**
- 메모리를 공유하므로 동기화, 교착상태와 같은 문제들을 고려해야한다.
- 하나의 스레드에서 문제가 발생해도 전체 프로세스가 영향을 받는다.

___

## 스케줄러
### 장기 스케줄러
장기 스케줄러는 작업 스케줄러라고도 부르며 어떤 프로세스를 준비 큐에 삽입할지를 결정하는 역할을 한다. 
즉 프로세스에게 메모리를 할당하는 문제에 관여를 하며 메모리에 동시에 올라가 있는 프로세스의 수를 조절한다.  
  
그러나 현대의 시분할 시스템에서는 장기 스케줄러를 두지 않고 곧바로 프로세스에게 메모리를 할당해 준비 큐에 넣어준다.

### 단기 스케줄러
단기 스케줄러는 CPU 스케줄러라고도 하며 준비 상태의 프로세스 중에서 어떤 프로세스를 실행 상태로 만들 것인지를 결정한다. 즉 준비 큐에 있는 프로세스들 중에 어떤 프로세스에게 CPU를 할당할 것인가를 결정하게 된다.

### 중기 스케줄러
메모리에 적재된 프로세스의 수가 너무 많아 성능이 저하되는 경우 프로세스의 수를 조절하기 위해 추가된 스케줄러이다. 
즉 프로세스당 보유 메모리량이 지나치게 적어진 경우 이를 완화하기 위해 일부 프로세스를 메모리에서 디스크로 스왑 아웃 시키는 역할을 수행한다.  
  
cf) **중지 상태**(suspended, stopped) : 중기 스케줄러의 등장으로 실행, 준비, 봉쇄 외에 하나의 프로세스 상태가 추가되었는데 외부적인 이유로 프로세스의 수행이 정지된 상태인 중지 상태이다.

___

## CPU 스케줄링 알고리즘
### FCFS(First Come First Served)
- 비선점형 스케줄링
- 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식
- CPU 버스트가 긴 프로세스가 먼저 도착하면 평균 대기 시간 증가

### SJF(Shortest Job First)
- 비선점형 스케줄링
- CPU 버스트가 가장 짧은 프로세스에게 CPU를 할당하는 방식
- 기아 현상(starvation) : CPU 버스트가 짧은 프로세스가 계속 도착할 경우 CPU 버스트가 긴 프로세스는 영원히 CPU를 할당받지 못한다.

### SRTF(Shortest Remaining Time First)
- 선점형 스케줄링
- SJF의 선점형 방식으로 현재 CPU에서 실행중인 프로세스의 남은 CPU 버스트 시간보다 더 짧은 CPU 버스트 시간을 가지는 프로세스가 도착하면 CPU를 뺏긴다.
- starvation

### 우선순위 스케줄링(Priority Scheduling)
- 선점형/비선점형 스케줄링
- 우선순위가 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식
- 우선순위값이 작을수록 높은 우선순위를 가진다.
- starvation
- aging : 기다리는 시간이 길어지면 우선순위를 조금씩 높여 CPU를 할당받을 수 있게 해주는 방법

### Round Robin
- 각 프로세스마다 동일한 할당 시간을 두어 이 시간이 경과하면 프로세스로부터 CPU를 회수해 준비 큐에 있는 다른 프로세스에게 CPU 할당
- 할당 시간이 지난 프로세스는 준비 큐의 제일 뒤에 가서 줄을 선다.
- 대기 시간이 CPU 버스트 시간에 비례하기 때문에 합리적인 알고리즘
- 할당 시간이 너무 길면 FCFS와 같은 결과가 나타나고 너무 짧으면 문맥 교환의 오버헤드가 커진다.

___

## 메모리 관리
### 단편화
메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 존재하지만 할당이 불가능한 상태를 말한다.
- 내부 단편화  
프로그램의 크기보다 메모리의 분할 공간의 크기가 더 큰 경우에 프로그램을 적재하고 남는 메모리 공간을 말한다. 
예를 들어 메모리의 분할 공간이 4kb인데 프로그램의 크기가 2kb라면 2kb의 공간이 남게 되고 이를 내부 단편화라고 한다.
- 외부 단편화  
프로그램의 크기보다 메모리 공간이 작은 경우에 프로그램을 적재하지 못하기 때문에 발생하는 메모리 공간을 말한다. 
예를 들어 메모리 할당 및 해제가 반복될 때 메모리 중간중간에 사용하지 않는 메모리가 존재하는데 이 공간에 프로세스를 할당할 수 없는 상황을 말한다.

### 페이징 기법
물리적 메모리를 동일한 크기의 프레임으로 나누고 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 페이지를 프레임에 불연속적으로 저장하는 방식을 말한다. 
페이징 기법에서는 같은 프로세스라고 하더라도 페이지 단위로 물리적 메모리의 위치가 다르므로 페이지 테이블을 사용하여 논리적 주소를 물리적 주소로 변환한다. 
논리적 주소는 <페이지 번호, 오프셋>으로 나뉘고 페이지 테이블에는 물리적 메모리의 기준 주소가 저장된다.  
  
페이징 기법을 사용하면 프로세스의 주소 공간 전체를 메모리에 한꺼번에 올릴 필요가 없이 일부만 메모리에 올릴 수 있다(가상 메모리). 
또한 프로세스를 메모리에 할당할 때 연속되어 저장할 필요가 없이 남는 프레임에 적절히 배치할 수 있어 동적 할당 문제가 발생하지 않는다. 
그리고 동일한 크기의 페이지와 프레임을 가지므로 외부 단편화가 발생하지 않는다.  
  
하지만 프로그램의 크기가 항상 페이지 크기의 배수가 되지는 않으므로 제일 마지막 페이지에서는 내부 단편화가 발생할 가능성이 있다.

### 세그먼테이션 기법
페이징 기법과 유사하지만 프로세스의 주소 공간을 동일한 크기가 아닌 의미 단위의 세그먼트로 나누어 물리적 메모리에 올리는 기법을 말한다. 
세그먼테이션 기법에서는 논리적 주소가 <세그먼트 번호, 오프셋>으로 나뉘고 기준점과 한계점을 담고 있는 세그먼트 테이블을 사용하여 물리적 주소를 계산한다.  
  
세그먼트는 단순히 크기가 아닌 의미 단위로 나누어져 있기 때문에 공유와 보안의 측면에서 페이징 기법보다 효과적이다.  
  
하지만 세그먼트의 길이가 균일하지 않으므로 외부 단편화가 발생할 수 있고 동적 할당 문제가 발생한다.  
  
cf) 동적 메모리 할당 문제 : 프로세스를 메모리에 올릴 때 물리적 메모리 내의 가용 공간 중 어떤 위치에 올릴 것인지를 결정하는 문제이다.
- 최초 적합 : 크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 곳에 할당
- 최적 적합 : 크기가 n 이상인 가장 작은 가용 공간을 찾아 할당
- 최악 적합 : 가장 큰 가용 공간에 할당

___

## 가상 메모리
프로그램이 실행되기 위해 그 프로세스의 주소 공간 전체가 메모리에 올라와 있어야 하는 것은 아니다. 
따라서 운영체제는 CPU에서 당장 수행해야 할 부분만을 메모리에 올려놓고 그렇지 않은 부분은 디스크의 스왑 영역에 내려놓았다가 다시 필요해지면 메모리에 올라가 있는 부분과 교체하는 방식을 사용한다. 
이와 같이 메모리의 연장 공간으로 디스크의 스왑 영역이 사용될 수 있기 때문에 운영체제는 프로그램이 물리적 메모리를 고려할 필요없이 자기 자신만이 메모리를 사용하는 것처럼 느끼도록 지원해준다. 
이렇게 되면 **프로그램은 0번지부터 시작하는 자기 자신만의 메모리 주소 공간을 가정할 수 있는데 이러한 메모리 공간을 가상 메모리라고 부른다.** 
즉 가상 메모리는 프로세스마다 각각 0번지부터의 주소 공간을 가지게 되며 이들 중 일부는 물리적 메모리, 일부는 디스크의 스왑 영역에 존재한다.

### 요구 페이징
프로그램 실행시 프로세스를 구성하는 모든 페이지를 메모리에 올리는 것이 아니라 당장 사용될 페이지만을 메모리에 올리는 방식을 말한다. 
따라서 요구 페이징 기법을 사용하면 메모리 사용량이 감소하고 프로세스 전체를 메모리에 올리는 데 들었던 입출력 오버헤드도 줄어든다. 
또한 물리적 메모리의 용량보다 큰 프로그램도 실행할 수 있다.  
  
요구 페이징에서는 페이지 테이블의 각 항목별로 유효-무효 비트를 두어 각 페이지가 메모리에 존재하는지를 표시한다. 
CPU가 참조하려는 페이지가 현재 메모리에 올라와 있지 않아 무효 비트로 세팅되어 있는 경우를 **페이지 부재**(page fault)가 일어났다고 한다.

### 페이지 교체 알고리즘
페이지 부재가 발생하면 요청된 페이지를 메모리로 읽어와야 한다. 
이 때 물리적 메모리에 빈 프레임이 존재하지 않으면 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫓아내 메모리에 빈 공간을 확보하는 작업이 필요하다. 
이를 **페이지 교체**(page replacement)라고 한다.

#### 최적 페이지 교체(optimal page replacement)
물리적 메모리에 존재하는 페이지 중 가장 먼 미래에 참조될 페이지를 교체하는 알고리즘으로 빌레디의 최적 알고리즘 이라고 부른다. 
이 알고리즘은 어떤 페이지가 어떠한 순서로 참조될지 미리 알고 있다는 전제의 알고리즘이므로 실제 시스템에서 사용하는 알고리즘은 아니다. 
빌레디의 최적 알고리즘은 가장 적은 페이지 부재율을 보장하므로 다른 알고리즘의 성능에 대한 상한선을 제공한다.

#### FIFO(First In First Out) 알고리즘
메모리에 가장 먼저 올라온 페이지를 교체하는 알고리즘이다. 페이지의 향후 참조 가능성을 고려하지 않고 메모리에 들어온 순서대로 교체하기 때문에 비효율적인 상황이 발생할 수 있다.  
  
페이지 프레임의 갯수를 늘려도 오히려 페이지 부재가 증가하는 상황이 발생할 수도 있다. 이러한 상황을 **FIFO의 이상현상**(FIFO anomaly)라고 부른다.

#### LRU(Least Recently Used) 알고리즘
최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질(temporal locality : 시간 지역성)을 활용해서 가장 오래 전에 참조된 페이지를 교체하는 알고리즘이다.

#### LFU(Least Frequently Used) 알고리즘
물리적 메모리에 존재하는 페이지 중에서 과거에 참조 횟수가 가장 적었던 페이지를 교체하는 알고리즘이다. 
LFU는 LRU보다 오랜 시간 동안의 참조 기록을 반영할 수 있지만 시간에 따른 페이지 참조의 변화를 반영하지 못하고 구현이 복잡하다.
- Incache-LFU : 메모리에 올라온 후부터의 참조 횟수
- Perfect-LFU : 총 참조 횟수

#### 클럭 알고리즘
LRU를 근사시킨 알고리즘으로 NUR(Not Used Recently) 또는 NRU(Not Recently Used) 알고리즘 으로도 불린다. 
클럭 알고리즘은 오랫동안 참조되지 않은 페이지 중 하나를 교체하지만 교체되는 페이지의 참조 시점이 가장 오래되었다는 것을 보장하지는 못한다. 
하지만 하드웨어적인 지원을 통해 LRU에 비해 교체 페이지의 선정이 훨씬 빠르게 결정된다. 따라서 대부분의 시스템에서 클럭 알고리즘을 사용한다.  
  
클럭 알고리즘은 교체할 페이지를 선정하기 위해 페이지 프레임들의 참조 비트를 순차적으로 조사하여 참조비트가 1인 페이지는 0으로 바꾼 후 지나가고 
참조비트가 0인 페이지는 교체한다.

### 스레싱
프로세스가 원활하게 수행되기 위해서는 일정 수준 이상의 프레임을 할당받아야 한다. 최소한의 프레임을 할당받지 못할 경우 페이지 부재율이 크게 상승해 CPU 이용률이 급격히 떨어질 수 있다.
이와 같은 현상을 **스레싱**(thrashing) 이라고 부른다.

#### 스레싱 발생 원인
운영체제는 CPU의 이용률이 낮을 경우 메모리에 올라와 있는 프로세스의 수가 적기 때문이라고 판단하고 메모리에 올라가는 프로세스의 수(MPD)를 늘리게 된다. 
그런데 MPD가 과도하게 높아지면 각 프로세스에게 할당되는 메모리의 양이 지나치게 감소하고 페이지 부재가 빈번히 발생하게 된다. 
페이지 부재가 발생하면 디스크 I/O 작업을 수반하므로 CPU가 다른 프로세스에게 이양된다. 이 때 다른 프로세스도 할당받은 메모리 양이 적으므로 페이지 부재가 발생한다. 
결국에는 시스템은 페이지 부재를 처리하느라 CPU의 이용률은 급격히 떨어지게 된다.

#### 해결방안
- 워킹셋 알고리즘  
프로세스가 일정 시간 동안 원활히 수행되기 위해 한꺼번에 메모리에 올라와 있어야 하는 페이지들의 집합을 워킹셋이라고 정의하고 워킹셋을 구성하는 페이지들이 한꺼번에 메모리에 올라갈 수 있는 경우에만 메모리를 할당한다. 
그렇지 않을 경우에는 프로세스에게 할당된 페이지 프레임을 모두 반납시킨 후 디스크로 스왑 아웃시킴으로써 MPD를 조절하고 스레싱을 방지한다.

- 페이지 부재 빈도 알고리즘  
프로세스의 페이지 부재율을 주기적으로 조사하여 메모리량을 조절한다. 어떤 프로세스의 페이지 부재율이 미리 정해 놓은 상한값을 넘게 되면 프레임을 추가로 할당하고 빈 프레임이 없으면 일부 프로세스를 스왑 아웃시킨다.
페이지 부재율이 하한값 이하로 떨어지면 할당된 프레임 수를 줄임으로써 MPD를 조절하고 스레싱을 방지한다.

___
